}
gammaOut[i,2]<-gam1
#elevation regression coef
gam2.star=rnorm(1,gam2,gam2.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2.star,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam2=gam2.star
accept.gam2=accept.gam2+1
}
gammaOut[i,3]<-gam2
# dispersal param
tau.star=rnorm(1,tau,tau.tune)
Out=UpdateDispersal(tmax=tmax,tau=tau.star,Nlat=Nlat,G=G,p=p,D=D)
Npred.star<-Out$Npred
M.star<-Out$M
now=UpdateDispersal(tmax=tmax,tau=tau,Nlat=Nlat,G=G,p=p,D=D)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
M=M.star
Minv<-chol2inv(M.star)
tau<-tau.star
accept.tau=accept.tau+1
}
tauOut[i,]<-tau
for (t in 2:tmax){
Npred[t,]<-M%*%(diag(G[t,])%*%Nlat[t-1,])
}
sig.p<-sqrt(sampleSigma(Nlat=c(Nlat[-1,]),Npred=c(Npred[-1,]),a=3,b=.5))
sig.pOut[i,]<-sig.p
#sig.o<-sqrt(sampleObS(Nlat=c(Nlat),N=c(N),a=3,b=.5))
sig.oOut[i,]<-sig.o
for (t in 1:tmax){
Nlat[t,]<-sampleLatent(Npred,Nlat,N,G,M,Minv,sig.o,sig.p,tmax)
}
NlatOut[,,i]<-Nlat[,rep.pix]
NlatOutLast[,i]<-Nlat[tmax,]
print(i)
if(i%%checkpoint==0){
if(accept.beta0/i<0.35) beta0.tune=beta0.tune*.9
if(accept.beta0/i>0.45) beta0.tune=beta0.tune*1.1
if(accept.beta1/i<0.35) beta1.tune=beta1.tune*.9
if(accept.beta1/i>0.45) beta1.tune=beta1.tune*1.1
if(accept.gam0/i<0.35) gam0.tune=gam0.tune*.9
if(accept.gam0/i>0.45) gam0.tune=gam0.tune*1.1
if(accept.gam1/i<0.35) gam1.tune=gam1.tune*.9
if(accept.gam1/i>0.45) gam1.tune=gam1.tune*1.1
if(accept.gam2/i<0.35) gam2.tune=gam2.tune*.9
if(accept.gam2/i>0.45) gam2.tune=gam2.tune*1.1
if(accept.tau/i<0.35) tau.tune=tau.tune*.9
if(accept.tau/i>0.45) tau.tune=tau.tune*1.1
}
}
###Starting Values###
Nlat<-N #Starting values for latent states is the observed data
beta0<-.01 ###Give beta some starting values based on what we know
beta1<--0.0001
tau<-.1###Give tau a reasonable starting value.
gam0 <- -0.01 # regression coef for vpdmax
gam1 <- 0 # regression coef for heatload
gam2 <- 0 # regression coef for elev
sig.p<-.1##give sig.p reasonable starting values
o1<-sig.o<-1##give sig.o reasonable starting values
ro <- 0.5
qo1 <- (ro/o1)+1
Mint<-exp(-(D/tau))
M<-t(Mint/apply(Mint,1,sum))  ##calculate M starting M given Tau
Npred<-G<-matrix(NA,tmax,pmax)
for (t in 2:tmax){
G[t,]<-exp((beta0+X[t,,1]*gam0+X[t,,2]*gam1+X[t,,3]*gam2)+beta1*Nlat[t-1,])
Npred[t,]<-M%*%(diag(G[t,])%*%Nlat[t-1,])
}
Niter<-20000 ###Number of interations. Keep in mind this will need to be more than you needed for stan
checkpoint=Niter*0.01
###Containers####
tauOut<-matrix(NA,Niter,)
betaOut<-matrix(NA,Niter,bmax)
gammaOut <- matrix(NA,Niter,3)
NlatOut<-array(NA,c(tmax,93,Niter)) # change to 93 pixels
NlatOutLast<-matrix(NA,pmax,Niter)
rep.pix <- c(115:145, 910:940, 1865:1895) # representative pixels (high,med,low density)
sig.pOut<-sig.oOut<-matrix(NA,Niter,1)
accept.gam0=accept.gam1=accept.gam2=accept.beta1=accept.beta0=accept.tau=0
#beta.tune=diag(c(.000001,.000001))
beta0.tune=.000001
beta1.tune=.0001
tau.tune=.001
gam0.tune=.001
gam1.tune=.001
gam2.tune=.001
for (i in 1:Niter){
# growth rate
beta0.star=rnorm(1,beta0,beta0.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0.star,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
beta0=beta0.star
accept.beta0=accept.beta0+1
}
betaOut[i,1]<-beta0
# density dependent param
beta1.star=rnorm(1,beta1,beta1.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1.star,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
beta1=beta1.star
accept.beta1=accept.beta1+1
}
betaOut[i,2]<-beta1
#vpdmax regression coef
gam0.star=rnorm(1,gam0,gam0.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0.star,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam0=gam0.star
accept.gam0=accept.gam0+1
}
gammaOut[i,1]<-gam0
#heatload regression coef
gam1.star=rnorm(1,gam1,gam1.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,star,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam1=gam1.star
accept.gam1=accept.gam1+1
}
gammaOut[i,2]<-gam1
#elevation regression coef
gam2.star=rnorm(1,gam2,gam2.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2.star,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam2=gam2.star
accept.gam2=accept.gam2+1
}
gammaOut[i,3]<-gam2
# dispersal param
tau.star=rnorm(1,tau,tau.tune)
Out=UpdateDispersal(tmax=tmax,tau=tau.star,Nlat=Nlat,G=G,p=p,D=D)
Npred.star<-Out$Npred
M.star<-Out$M
now=UpdateDispersal(tmax=tmax,tau=tau,Nlat=Nlat,G=G,p=p,D=D)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
M=M.star
Minv<-chol2inv(M.star)
tau<-tau.star
accept.tau=accept.tau+1
}
tauOut[i,]<-tau
for (t in 2:tmax){
Npred[t,]<-M%*%(diag(G[t,])%*%Nlat[t-1,])
}
sig.p<-sqrt(sampleSigma(Nlat=c(Nlat[-1,]),Npred=c(Npred[-1,]),a=3,b=.5))
sig.pOut[i,]<-sig.p
#sig.o<-sqrt(sampleObS(Nlat=c(Nlat),N=c(N),a=3,b=.5))
sig.oOut[i,]<-sig.o
for (t in 1:tmax){
Nlat[t,]<-sampleLatent(Npred,Nlat,N,G,M,Minv,sig.o,sig.p,tmax)
}
NlatOut[,,i]<-Nlat[,rep.pix]
NlatOutLast[,i]<-Nlat[tmax,]
print(i)
if(i%%checkpoint==0){
if(accept.beta0/i<0.35) beta0.tune=beta0.tune*.9
if(accept.beta0/i>0.45) beta0.tune=beta0.tune*1.1
if(accept.beta1/i<0.35) beta1.tune=beta1.tune*.9
if(accept.beta1/i>0.45) beta1.tune=beta1.tune*1.1
if(accept.gam0/i<0.35) gam0.tune=gam0.tune*.9
if(accept.gam0/i>0.45) gam0.tune=gam0.tune*1.1
if(accept.gam1/i<0.35) gam1.tune=gam1.tune*.9
if(accept.gam1/i>0.45) gam1.tune=gam1.tune*1.1
if(accept.gam2/i<0.35) gam2.tune=gam2.tune*.9
if(accept.gam2/i>0.45) gam2.tune=gam2.tune*1.1
if(accept.tau/i<0.35) tau.tune=tau.tune*.9
if(accept.tau/i>0.45) tau.tune=tau.tune*1.1
}
}
#vpdmax regression coef
gam0.star=rnorm(1,gam0,gam0.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0.star,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam0=gam0.star
accept.gam0=accept.gam0+1
}
gammaOut[i,1]<-gam0
#heatload regression coef
gam1.star=rnorm(1,gam1,gam1.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,star,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1.star,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam1=gam1.star
accept.gam1=accept.gam1+1
}
gammaOut[i,2]<-gam1
#elevation regression coef
gam2.star=rnorm(1,gam2,gam2.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2.star,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam2=gam2.star
accept.gam2=accept.gam2+1
}
gammaOut[i,3]<-gam2
###Starting Values###
Nlat<-N #Starting values for latent states is the observed data
beta0<-.01 ###Give beta some starting values based on what we know
beta1<--0.0001
tau<-.1###Give tau a reasonable starting value.
gam0 <- -0.01 # regression coef for vpdmax
gam1 <- 0 # regression coef for heatload
gam2 <- 0 # regression coef for elev
sig.p<-.1##give sig.p reasonable starting values
o1<-sig.o<-1##give sig.o reasonable starting values
ro <- 0.5
qo1 <- (ro/o1)+1
Mint<-exp(-(D/tau))
M<-t(Mint/apply(Mint,1,sum))  ##calculate M starting M given Tau
Npred<-G<-matrix(NA,tmax,pmax)
for (t in 2:tmax){
G[t,]<-exp((beta0+X[t,,1]*gam0+X[t,,2]*gam1+X[t,,3]*gam2)+beta1*Nlat[t-1,])
Npred[t,]<-M%*%(diag(G[t,])%*%Nlat[t-1,])
}
Niter<-20000 ###Number of interations. Keep in mind this will need to be more than you needed for stan
checkpoint=Niter*0.01
###Containers####
tauOut<-matrix(NA,Niter,)
betaOut<-matrix(NA,Niter,bmax)
gammaOut <- matrix(NA,Niter,3)
NlatOut<-array(NA,c(tmax,93,Niter)) # change to 93 pixels
NlatOutLast<-matrix(NA,pmax,Niter)
rep.pix <- c(115:145, 910:940, 1865:1895) # representative pixels (high,med,low density)
sig.pOut<-sig.oOut<-matrix(NA,Niter,1)
accept.gam0=accept.gam1=accept.gam2=accept.beta1=accept.beta0=accept.tau=0
#beta.tune=diag(c(.000001,.000001))
beta0.tune=.000001
beta1.tune=.0001
tau.tune=.001
gam0.tune=.001
gam1.tune=.001
gam2.tune=.001
for (i in 1:Niter){
# growth rate
beta0.star=rnorm(1,beta0,beta0.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0.star,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
beta0=beta0.star
accept.beta0=accept.beta0+1
}
betaOut[i,1]<-beta0
# density dependent param
beta1.star=rnorm(1,beta1,beta1.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1.star,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
beta1=beta1.star
accept.beta1=accept.beta1+1
}
betaOut[i,2]<-beta1
#vpdmax regression coef
gam0.star=rnorm(1,gam0,gam0.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0.star,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam0=gam0.star
accept.gam0=accept.gam0+1
}
gammaOut[i,1]<-gam0
#heatload regression coef
gam1.star=rnorm(1,gam1,gam1.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1.star,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam1=gam1.star
accept.gam1=accept.gam1+1
}
gammaOut[i,2]<-gam1
#elevation regression coef
gam2.star=rnorm(1,gam2,gam2.tune)
Out=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2.star,Nlat=Nlat,M=M,p=p)
Npred.star<-Out$Npred
G.star<-Out$G
now=UpdateBetaToCl(tmax=tmax,b0=beta0,b1=beta1,X=X,gamma0=gam0,gamma1=gam1,gamma2=gam2,Nlat=Nlat,M=M,p=p)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
G=G.star
gam2=gam2.star
accept.gam2=accept.gam2+1
}
gammaOut[i,3]<-gam2
# dispersal param
tau.star=rnorm(1,tau,tau.tune)
Out=UpdateDispersal(tmax=tmax,tau=tau.star,Nlat=Nlat,G=G,p=p,D=D)
Npred.star<-Out$Npred
M.star<-Out$M
now=UpdateDispersal(tmax=tmax,tau=tau,Nlat=Nlat,G=G,p=p,D=D)
Npred<-now$Npred
mh1=sum(dnorm(Nlat[-1,],(Npred.star[-1,]),sig.p,log=TRUE)) #implied uniform prior
mh2=sum(dnorm(Nlat[-1,],(Npred[-1,]),sig.p,log=TRUE))      #implied uniform prior
mh=min(exp(mh1-mh2),1)
if(mh>runif(1)){
M=M.star
Minv<-chol2inv(M.star)
tau<-tau.star
accept.tau=accept.tau+1
}
tauOut[i,]<-tau
for (t in 2:tmax){
Npred[t,]<-M%*%(diag(G[t,])%*%Nlat[t-1,])
}
sig.p<-sqrt(sampleSigma(Nlat=c(Nlat[-1,]),Npred=c(Npred[-1,]),a=3,b=.5))
sig.pOut[i,]<-sig.p
#sig.o<-sqrt(sampleObS(Nlat=c(Nlat),N=c(N),a=3,b=.5))
sig.oOut[i,]<-sig.o
for (t in 1:tmax){
Nlat[t,]<-sampleLatent(Npred,Nlat,N,G,M,Minv,sig.o,sig.p,tmax)
}
NlatOut[,,i]<-Nlat[,rep.pix]
NlatOutLast[,i]<-Nlat[tmax,]
print(i)
if(i%%checkpoint==0){
if(accept.beta0/i<0.35) beta0.tune=beta0.tune*.9
if(accept.beta0/i>0.45) beta0.tune=beta0.tune*1.1
if(accept.beta1/i<0.35) beta1.tune=beta1.tune*.9
if(accept.beta1/i>0.45) beta1.tune=beta1.tune*1.1
if(accept.gam0/i<0.35) gam0.tune=gam0.tune*.9
if(accept.gam0/i>0.45) gam0.tune=gam0.tune*1.1
if(accept.gam1/i<0.35) gam1.tune=gam1.tune*.9
if(accept.gam1/i>0.45) gam1.tune=gam1.tune*1.1
if(accept.gam2/i<0.35) gam2.tune=gam2.tune*.9
if(accept.gam2/i>0.45) gam2.tune=gam2.tune*1.1
if(accept.tau/i<0.35) tau.tune=tau.tune*.9
if(accept.tau/i>0.45) tau.tune=tau.tune*1.1
}
}
plot(gammaOut[,1], type = "l")
plot(gammaOut[,1], type = "l")
plot(gammaOut[1:20,1], type = "l")
plot(gammaOut[1:20,2], type = "l")
plot(gammaOut[1:20,3], type = "l")
plot(betaOut[1:20,1], type = "l")
plot(betaOut[1:20,2], type = "l")
plot(tauOut[1:20], type = "l")
NlatOut<-array(NA,c(tmax,pmax,Niter/10)) # change to all pixels, but only every 10th iteration
NlatOut<-array(NA,c(31,21352,20000/10)) # change to all pixels, but only every 10th iteration
NlatOut<-array(NA,c(31,2352,20000/10)) # change to all pixels, but only every 10th iteration
dim(NlatOut)
#rep.pix <- c(115:145, 910:940, 1865:1895) # representative pixels (high,med,low density)
Nlatsub <- seq(1:20000, by = 10)
?seq
#rep.pix <- c(115:145, 910:940, 1865:1895) # representative pixels (high,med,low density)
Nlatsub <- seq(1,20000, by = 10)
Nlatsub
20000/50
2000/20
20000/20
length(Nlatsub)
Niter/10
Niter<-20000 ###Number of interations. Keep in mind this will need to be more than you needed for stan
Niter/10
#rep.pix <- c(115:145, 910:940, 1865:1895) # representative pixels (high,med,low density)
tenIter <- seq(1,20000, by = 10) # vecotr of every 10th iteration
for (t in 1:100){
if([t]==tenIter){}
if([t]==tenIter){print(yo)}
for (t in 1:100){
if([t]==tenIter){print(yo)}
for (t in 1:100){
if(t==tenIter){print(yo)}
}
i = 10
if(i/10==tenIter[i]){
NlatOut[,,i] <- Nlat}
tenIter
i=11
if(i==tenIter[i/10]){
print("yo!")
}
if(i==tenIter[i]){
print("yo!")}
i
tenIter[i]
101/10
101/11
if(i==tenIter[(i-1)/10]){
print("yo!")
}
i
tenIter[i-1]
tenIter[i]
tenIter[(i-1)]
tenIter[i]-1/10
tenIter[i]-1
i
if(i==(tenIter[i]-1)/10){
print("yo!")}
tenIter[i]-1)/10
(tenIter[i]-1)/10
((tenIter[i]-1)/10))
((tenIter[i]-1)/10)
if(i==((tenIter[i]-1)/10)){
print("yo!")}
for(i 1:100) {}
for(i in 1:100) {
if(i==((tenIter[i]-1)/10)){
print("yo!")}}
for(i in 1:Niter) {
if(Niter[i]==((tenIter[i]-1)/10)){
print("yo!")}}
